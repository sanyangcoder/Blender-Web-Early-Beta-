<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>GLB Viewer â€” More Lighting Options & Dragging</title>
<style>
html,body {margin:0;height:100%;overflow:hidden;background:#111;}
#info {
  position:absolute;top:10px;left:10px;
  background:rgba(0,0,0,0.5);color:#fff;
  padding:8px 12px;font-family:sans-serif;border-radius:6px;
  user-select:none;
  z-index: 10;
}
#dropzone {
  position:absolute;top:0;left:0;right:0;bottom:0;
  background:rgba(255,255,255,0.05);
  color:white;font-size:20px;
  display:none;justify-content:center;align-items:center;
  pointer-events:none;
  z-index: 5;
}
button {
  margin: 5px 5px 0 0;
  background: #222;
  color: #eee;
  border: none;
  padding: 5px 10px;
  cursor: pointer;
  border-radius: 4px;
}
button:hover { background: #444; }

/* Shift+A menu styles */
#addMenu {
  position: absolute;
  background: #222;
  border: 1px solid #555;
  border-radius: 6px;
  box-shadow: 0 0 10px #000;
  display: none;
  color: white;
  font-family: sans-serif;
  z-index: 20;
  min-width: 140px;
  user-select:none;
}
#addMenu div {
  padding: 8px 12px;
  cursor: pointer;
  border-bottom: 1px solid #444;
}
#addMenu div:last-child {
  border-bottom: none;
}
#addMenu div:hover {
  background: #444;
}
</style>
</head>
<body>
<div id="info">
  Drop a .glb file anywhere.<br>
  Drag glowing spheres = move lights.<br>
  <b>G</b>=Move, <b>R</b>=Rotate, <b>S</b>=Scale model.<br>
  Hold <b>Shift</b> to disable snapping while transforming.<br><br>
  <button id="resetBtn">Reset Transform</button>
  <button id="toggleWireframeBtn">Toggle Wireframe</button>
  <button id="toggleGridBtn">Toggle Grid</button><br>
  <label for="lightColor">Main Point Light Color:</label>
  <input type="color" id="lightColor" value="#ffccaa" style="vertical-align:middle;"><br>
  <button id="toggleSpotlightsBtn">Toggle Spotlights</button>
  <button id="toggleAreaLightsBtn">Toggle Area Lights</button>
</div>

<div id="addMenu">
  <div data-type="cube">Add Cube</div>
  <div data-type="cone">Add Cone</div>
  <div data-type="sphere">Add Sphere</div>
  <div data-type="pointlight">Add Point Light</div>
  <div data-type="spotlight">Add Spot Light</div>
  <div data-type="arealight">Add Area Light</div>
</div>

<div id="dropzone">Drop your .glb file here</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.120.1/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.120.1/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.120.1/examples/js/controls/TransformControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.120.1/examples/js/loaders/GLTFLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.120.1/examples/js/lights/RectAreaLightUniformsLib.js"></script>

<script>
/* ============== INIT RectAreaLight support =============== */
THREE.RectAreaLightUniformsLib.init();

/* =========================
   Scene + Renderer + Camera
   ========================= */
var scene = new THREE.Scene();
scene.background = new THREE.Color(0x111111);

var camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(3,3,6);

var renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

var controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

/* =========================
   Transform Controls
   ========================= */
var transformControls = new THREE.TransformControls(camera, renderer.domElement);
transformControls.addEventListener('dragging-changed', function (event) {
  controls.enabled = !event.value;
});
scene.add(transformControls);

/* =========================
   Lights / Ground / Helpers
   ========================= */
var hemi = new THREE.HemisphereLight(0x808080, 0x202020, 0.25);
scene.add(hemi);

var dir = new THREE.DirectionalLight(0xffffff, 0.18);
dir.position.set(-5,8,2);
dir.castShadow = true;
scene.add(dir);

var gmat = new THREE.MeshStandardMaterial({color:0x222222, roughness:0.9, metalness:0.05});
var ground = new THREE.Mesh(new THREE.PlaneBufferGeometry(50,50), gmat);
ground.rotation.x = -Math.PI/2;
ground.position.y = -1.2;
ground.receiveShadow = true;
scene.add(ground);

var gridHelper = new THREE.GridHelper(50, 50, 0x444444, 0x222222);
gridHelper.position.y = -1.19;
scene.add(gridHelper);
gridHelper.visible = true;

/* Main point light + draggable sphere */
var pointLight = new THREE.PointLight(0xffccaa, 2.2, 20, 2);
pointLight.castShadow = true;
pointLight.position.set(3,2,0);
scene.add(pointLight);

var sGeo = new THREE.SphereBufferGeometry(0.12, 16, 12);
var sMat = new THREE.MeshStandardMaterial({emissive:0xffaa66, emissiveIntensity:1, metalness:1, roughness:0.2});
var lightSphere = new THREE.Mesh(sGeo, sMat);
lightSphere.position.copy(pointLight.position);
scene.add(lightSphere);

/* Materials for other light spheres */
var spotLightSphereMat = new THREE.MeshStandardMaterial({emissive: 0x66aaff, emissiveIntensity: 1, metalness: 1, roughness: 0.2});
var areaLightSphereMat = new THREE.MeshStandardMaterial({emissive: 0xff66cc, emissiveIntensity: 1, metalness: 1, roughness: 0.2});

/* =========================
   Selectable objects storage
   ========================= */
var selectableObjects = []; // top-level selectable objects

/* helper to find top-level selectable root */
function getSelectableRoot(obj) {
  if (!obj) return null;
  var cur = obj;
  while (cur.parent && cur.parent !== scene) {
    cur = cur.parent;
  }
  return cur;
}

/* =========================
   GLTF Loader
   ========================= */
var loader = new THREE.GLTFLoader();

var currentSelection = null;
var originalTransform = null;

function selectRootObject(root) {
  if (!root) return;
  currentSelection = root;
  transformControls.attach(root);
  originalTransform = {
    position: root.position.clone(),
    rotation: root.rotation.clone(),
    scale: root.scale.clone()
  };
}

function deselect() {
  currentSelection = null;
  originalTransform = null;
  transformControls.detach();
}

/* =========================
   Drag & Drop GLB support
   ========================= */
var dropzone = document.getElementById("dropzone");
window.addEventListener("dragover", function(e){
  e.preventDefault();
  dropzone.style.display = "flex";
});
window.addEventListener("dragleave", function(e){
  dropzone.style.display = "none";
});
window.addEventListener("drop", function(e){
  e.preventDefault();
  dropzone.style.display = "none";
  var file = e.dataTransfer.files && e.dataTransfer.files[0];
  if(file && file.name.toLowerCase().endsWith(".glb")){
    var reader = new FileReader();
    reader.onload = function(ev){
      var arrayBuffer = ev.target.result;
      loader.parse(arrayBuffer, '', function(gltf){
        var modelRoot = gltf.scene;
        modelRoot.position.set(0,-1.2,0);
        modelRoot.traverse(function(node){
          if(node.isMesh){
            node.castShadow = true;
            node.receiveShadow = true;
          }
        });
        scene.add(modelRoot);

        selectableObjects.push(modelRoot);
        selectRootObject(modelRoot);
      }, function(err){ console.error(err); alert("Error parsing glb"); });
    };
    reader.readAsArrayBuffer(file);
  } else {
    alert("Please drop a .glb file.");
  }
});

/* =========================
   Raycasting + Pointer helpers
   ========================= */
var raycaster = new THREE.Raycaster();
var pointer = new THREE.Vector2();

function getPointer(event){
  var rect = renderer.domElement.getBoundingClientRect();
  pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
  pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
}

/* =========================
   Light dragging helper
   ========================= */
function makeLightDraggable(sphereMesh, lightObj){
  sphereMesh.userData.pointLight = lightObj;

  var dragging = false;
  var plane = new THREE.Plane();
  var intersect = new THREE.Vector3();

  function onPointerDown(event){
    getPointer(event);
    raycaster.setFromCamera(pointer, camera);
    var intersects = raycaster.intersectObject(sphereMesh, true);
    if(intersects.length > 0){
      dragging = true;
      var camDir = new THREE.Vector3();
      camera.getWorldDirection(camDir);
      plane.setFromNormalAndCoplanarPoint(camDir.clone().negate(), sphereMesh.position);
      controls.enabled = false;
      event.preventDefault();
    }
  }
  function onPointerMove(event){
    if(!dragging) return;
    getPointer(event);
    raycaster.setFromCamera(pointer, camera);
    if(raycaster.ray.intersectPlane(plane, intersect)){
      intersect.y = Math.max(intersect.y, -0.2);
      sphereMesh.position.copy(intersect);
      lightObj.position.copy(intersect);
    }
  }
  function onPointerUp(event){
    if(dragging){
      dragging = false;
      controls.enabled = true;
    }
  }

  renderer.domElement.addEventListener('pointerdown', onPointerDown);
  renderer.domElement.addEventListener('pointermove', onPointerMove);
  window.addEventListener('pointerup', onPointerUp);
}

/* attach dragging to main point light sphere */
makeLightDraggable(lightSphere, pointLight);
selectableObjects.push(lightSphere);

/* =========================
   Pointer interaction: select objects or drag lights
   ========================= */
var currentlyDraggingLight = false;
var dragPlane = new THREE.Plane();
var dragIntersect = new THREE.Vector3();
var activeLightBeingDragged = null;

renderer.domElement.addEventListener('pointerdown', function(e){
  getPointer(e);
  raycaster.setFromCamera(pointer, camera);

  var hits = raycaster.intersectObjects(selectableObjects, true);
  if(hits.length === 0){
    deselect();
    return;
  }

  var hit = hits[0].object;
  var hitRoot = getSelectableRoot(hit);

  if(hitRoot && hitRoot.userData && hitRoot.userData.pointLight){
    activeLightBeingDragged = hitRoot;
    currentlyDraggingLight = true;
    var camDir = new THREE.Vector3();
    camera.getWorldDirection(camDir);
    dragPlane.setFromNormalAndCoplanarPoint(camDir.clone().negate(), activeLightBeingDragged.position);
    controls.enabled = false;
    transformControls.detach();
    currentSelection = activeLightBeingDragged;
    originalTransform = null;
    return;
  }

  var root = getSelectableRoot(hit);
  if(!root) root = hit;
  if(root === scene) {
    deselect();
    return;
  }
  selectRootObject(root);
});

renderer.domElement.addEventListener('pointermove', function(e){
  getPointer(e);
  if(currentlyDraggingLight && activeLightBeingDragged){
    raycaster.setFromCamera(pointer, camera);
    if(raycaster.ray.intersectPlane(dragPlane, dragIntersect)){
      dragIntersect.y = Math.max(dragIntersect.y, -0.2);
      activeLightBeingDragged.position.copy(dragIntersect);
      if(activeLightBeingDragged.userData.pointLight){
        activeLightBeingDragged.userData.pointLight.position.copy(dragIntersect);
      } else if(activeLightBeingDragged === lightSphere) {
        pointLight.position.copy(dragIntersect);
      }
    }
  }
});

window.addEventListener('pointerup', function(){
  if(currentlyDraggingLight){
    currentlyDraggingLight = false;
    activeLightBeingDragged = null;
    controls.enabled = true;
  }
});

/* =========================
   Keyboard (G/R/S + Shift snap toggle + Shift+A menu)
   ========================= */
window.addEventListener('keydown', function(e){
  if(e.key.toLowerCase() === 'g'){ transformControls.setMode('translate'); }
  if(e.key.toLowerCase() === 'r'){ transformControls.setMode('rotate'); }
  if(e.key.toLowerCase() === 's'){ transformControls.setMode('scale'); }
  if(e.key === 'Shift') {
    transformControls.setTranslationSnap(null);
    transformControls.setRotationSnap(null);
    transformControls.setScaleSnap(null);
  }
  if(e.key === 'A' && e.shiftKey) {
    e.preventDefault();
    showAddMenu(e.clientX, e.clientY);
  }
});
window.addEventListener('keyup', function(e){
  if(e.key === 'Shift') {
    transformControls.setTranslationSnap(snapEnabled ? snapStep : null);
    transformControls.setRotationSnap(snapEnabled ? THREE.Math.degToRad(15) : null);
    transformControls.setScaleSnap(snapEnabled ? snapStep : null);
  }
});

/* =========================
   Window resize
   ========================= */
window.addEventListener('resize', function(){
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

/* =========================
   Snapping defaults
   ========================= */
var snapEnabled = true;
var snapStep = 0.1;
transformControls.setTranslationSnap(snapEnabled ? snapStep : null);
transformControls.setRotationSnap(snapEnabled ? THREE.Math.degToRad(15) : null);
transformControls.setScaleSnap(snapEnabled ? snapStep : null);

/* =========================
   Reset / Wireframe / Grid / Buttons
   ========================= */
var wireframeOn = false;

function resetTransform() {
  if (!currentSelection || !originalTransform) return;
  currentSelection.position.copy(originalTransform.position);
  currentSelection.rotation.copy(originalTransform.rotation);
  currentSelection.scale.copy(originalTransform.scale);
}

document.getElementById('resetBtn').onclick = () => { resetTransform(); };

document.getElementById('toggleWireframeBtn').onclick = () => {
  if (!currentSelection) return;
  wireframeOn = !wireframeOn;
  currentSelection.traverse
    ? currentSelection.traverse((node) => { if (node.isMesh) node.material.wireframe = wireframeOn; })
    : (currentSelection.material.wireframe = wireframeOn);
};

document.getElementById('toggleGridBtn').onclick = () => {
  gridHelper.visible = !gridHelper.visible;
};

/* Light color for main point light */
document.getElementById('lightColor').addEventListener('input', (e) => {
  var col = new THREE.Color(e.target.value);
  pointLight.color = col;
  sMat.emissive = col;
});

/* =========================
   Lighting arrays for toggling
   ========================= */
var spotLights = [];
var areaLights = [];

/* Helper to add lights to arrays */
function addSpotLight(spotLight, sphere) {
  spotLights.push({ light: spotLight, helper: sphere });
}
function addAreaLight(areaLight, sphere) {
  areaLights.push({ light: areaLight, helper: sphere });
}

/* =========================
   Spawn new objects
   ========================= */
function createMesh(geometry) {
  var mat = new THREE.MeshStandardMaterial({color:0x999999, roughness:0.6, metalness:0.2});
  var mesh = new THREE.Mesh(geometry, mat);
  mesh.castShadow = true;
  mesh.receiveShadow = true;
  return mesh;
}

function spawnObject(type) {
  var obj = null;
  var spawnPos = new THREE.Vector3();
  camera.getWorldDirection(spawnPos);
  spawnPos.multiplyScalar(2);
  spawnPos.add(camera.position);
  spawnPos.y = Math.max(spawnPos.y, -1);

  switch(type) {
    case 'cube':
      obj = createMesh(new THREE.BoxBufferGeometry(1,1,1));
      break;
    case 'cone':
      obj = createMesh(new THREE.ConeBufferGeometry(0.7, 1.5, 16));
      break;
    case 'sphere':
      obj = createMesh(new THREE.SphereBufferGeometry(0.7, 24, 16));
      break;
    case 'pointlight':
      var light = new THREE.PointLight(0xffffff, 1.5, 20, 2);
      light.position.copy(spawnPos);
      light.castShadow = true;
      scene.add(light);

      var glowMat = new THREE.MeshStandardMaterial({emissive:0xffffff, emissiveIntensity:1, metalness:1, roughness:0.2});
      var glowSphere = new THREE.Mesh(sGeo, glowMat);
      glowSphere.position.copy(spawnPos);
      scene.add(glowSphere);

      makeLightDraggable(glowSphere, light);
      selectableObjects.push(glowSphere);
      deselect();
      hideAddMenu();
      return;

    case 'spotlight':
      var spotLight = new THREE.SpotLight(0x66aaff, 2, 20, Math.PI / 6, 0.5, 1);
      spotLight.position.copy(spawnPos);
      spotLight.castShadow = true;
      scene.add(spotLight);

      var targetObj = new THREE.Object3D();
      targetObj.position.set(spawnPos.x, spawnPos.y - 1, spawnPos.z);
      scene.add(targetObj);
      spotLight.target = targetObj;

      var spotSphere = new THREE.Mesh(sGeo, spotLightSphereMat);
      spotSphere.position.copy(spawnPos);
      scene.add(spotSphere);

      makeLightDraggable(spotSphere, spotLight);
      selectableObjects.push(spotSphere);
      addSpotLight(spotLight, spotSphere);
      deselect();
      hideAddMenu();
      return;

    case 'arealight':
      var areaLight = new THREE.RectAreaLight(0xff66cc, 3, 3, 2);
      areaLight.position.copy(spawnPos);
      areaLight.lookAt(spawnPos.x, spawnPos.y - 1, spawnPos.z);
      scene.add(areaLight);

      var areaSphere = new THREE.Mesh(sGeo, areaLightSphereMat);
      areaSphere.position.copy(spawnPos);
      scene.add(areaSphere);

      makeLightDraggable(areaSphere, areaLight);
      selectableObjects.push(areaSphere);
      addAreaLight(areaLight, areaSphere);
      deselect();
      hideAddMenu();
      return;
  }

  obj.position.copy(spawnPos);
  scene.add(obj);
  selectableObjects.push(obj);
  selectRootObject(obj);
  hideAddMenu();
}

document.querySelectorAll('#addMenu div').forEach(function(item){
  item.addEventListener('click', function(){
    spawnObject(this.getAttribute('data-type'));
  });
});

/* =========================
   Toggle Spotlights & Area Lights visibility
   ========================= */
var spotlightsVisible = true;
var arealightsVisible = true;

document.getElementById('toggleSpotlightsBtn').onclick = () => {
  spotlightsVisible = !spotlightsVisible;
  spotLights.forEach(({light, helper}) => {
    light.visible = spotlightsVisible;
    helper.visible = spotlightsVisible;
  });
};

document.getElementById('toggleAreaLightsBtn').onclick = () => {
  arealightsVisible = !arealightsVisible;
  areaLights.forEach(({light, helper}) => {
    light.visible = arealightsVisible;
    helper.visible = arealightsVisible;
  });
};

/* =========================
   Animation loop
   ========================= */
function animate(){
  requestAnimationFrame(animate);
  var pulse = 1 + Math.sin(Date.now()*0.003)*0.07;
  pointLight.intensity = 2.2 * pulse;
  controls.update();
  renderer.render(scene, camera);
}
animate();

/* =========================
   SHIFT + A Add Menu
   ========================= */
var addMenu = document.getElementById('addMenu');
function showAddMenu(x, y) {
  addMenu.style.left = x + 'px';
  addMenu.style.top = y + 'px';
  addMenu.style.display = 'block';
}
function hideAddMenu() { addMenu.style.display = 'none'; }
window.addEventListener('click', function(e) {
  if (!addMenu.contains(e.target)) hideAddMenu();
});
</script>
</body>
</html>
